# 时间管理计分系统存储优化建议（Python→iOS 去服务器化）
核心优化目标：**本地存储轻量化、跨平台兼容、读写高效、数据可靠**，适配“先Python验证功能，后移植iOS”的去服务器化场景。

## 一、存储引擎选型（核心兼容层）
优先选择跨平台的轻量存储引擎，避免后期移植时数据迁移成本，同时满足本地读写性能要求：

| 阶段       | 存储引擎选择                | 选型理由                                                                 |
|------------|-----------------------------|--------------------------------------------------------------------------|
| Python验证 | SQLite（内置`sqlite3`库）| 轻量无服务、结构化查询、iOS原生支持（Core Data/FMDB底层均为SQLite），避免JSON/纯文本的全量读写低效问题； |
| iOS移植    | Core Data（封装SQLite）/FMDB | Core Data适配iOS UI生命周期（如UITableView数据绑定），FMDB更贴近原生SQLite，兼容Python端表结构； |

### 避坑提醒：
- 拒绝使用`pickle`（Python独有）、`JSON文件全量读写`（数据量>100条后读写卡顿）；
- iOS端禁用UserDefaults存储核心业务数据（仅用于缓存配置），其设计目标是“小量配置”，而非大量行为记录存储。

## 二、结构化数据设计（减少冗余+提升查询效率）
基于业务逻辑拆分表结构，避免单表冗余，同时适配计分系统的核心数据维度：

### 1. 核心表结构设计（Python/iOS通用）
```sql
-- 1. 行为记录表（核心业务数据）
CREATE TABLE core_behavior (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- 主键
    level INTEGER NOT NULL,               -- 等级映射（S=5/A=4/B=3/C=2/D=1，替代字符串，节省空间）
    duration INTEGER NOT NULL,            -- 时长（分钟，整型）
    mood INTEGER DEFAULT 3,               -- 心情（1-5，默认3）
    start_ts INTEGER NOT NULL,            -- 开始时间戳（Unix整型，便于时段筛选）
    end_ts INTEGER NOT NULL,              -- 结束时间戳
    base_score REAL,                      -- 基础分（预计算，避免重复计算）
    dynamic_coeff REAL,                   -- 动态系数（精力×时段×连击×幸运）
    final_score REAL,                     -- 单次最终得分
    energy_consume REAL,                  -- 精力消耗
    create_ts INTEGER DEFAULT (strftime('%s', 'now')),  -- 创建时间
    md5_check TEXT                        -- 数据校验码（防损坏）
);

-- 2. 用户状态表（实时更新的轻量状态）
CREATE TABLE user_state (
    id INTEGER PRIMARY KEY DEFAULT 1,     -- 单条记录存储全局状态
    current_energy REAL DEFAULT 100,      -- 当前精力值
    combo_count INTEGER DEFAULT 0,        -- 连击数
    today_total_score REAL DEFAULT 0,     -- 今日总积分（缓存，避免实时求和）
    today_behavior_count INTEGER DEFAULT 0, -- 当日记录数（用于幸运系数衰减）
    last_record_ts INTEGER,               -- 最后记录时间（用于精力恢复计算）
    efficient_periods TEXT                -- 高效时段（JSON字符串，如["0900-1100","1500-1700"]）
);

-- 3. 配置表（静态/个性化规则）
CREATE TABLE system_config (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    key TEXT UNIQUE NOT NULL,             -- 配置键（如"newbie_boost"/"anti_cheat"）
    value TEXT NOT NULL                   -- 配置值（JSON封装，如{"enable":true,"ratio":1.2}）
);

-- 4. 成就表（轻量化存储）
CREATE TABLE user_achievement (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL,                   -- 成就类型（如"50_score"/"combo_3"）
    unlock_ts INTEGER,                    -- 解锁时间戳
    count INTEGER DEFAULT 1               -- 累计次数
);
```

### 2. 数据类型优化原则
- 数值型字段（时长、得分、系数）用`REAL/INTEGER`，避免字符串存储（解析耗时+占空间）；
- 枚举型字段（等级、心情）用整型映射，减少字符串比对开销；
- 时间类字段用Unix时间戳（整型），替代`YYYY-MM-DD HH:MM:SS`字符串（便于时段系数计算、范围查询）。

## 三、读写性能优化（适配高频记录场景）
### 1. 批量读写+事务封装
避免单条记录高频写库，减少IO开销（Python/iOS通用逻辑）：
```python
# Python示例：事务批量写入行为记录
import sqlite3

def batch_insert_behavior(behavior_list):
    conn = sqlite3.connect('time_manage.db')
    cursor = conn.cursor()
    try:
        conn.execute('BEGIN TRANSACTION')  # 开启事务
        for behavior in behavior_list:
            cursor.execute('''
                INSERT INTO core_behavior (level, duration, mood, start_ts, end_ts, base_score, dynamic_coeff, final_score, energy_consume)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (behavior['level'], behavior['duration'], behavior['mood'], behavior['start_ts'], 
                  behavior['end_ts'], behavior['base_score'], behavior['dynamic_coeff'], behavior['final_score'], behavior['energy_consume']))
        conn.commit()  # 批量提交
    except Exception as e:
        conn.rollback()  # 失败回滚
        raise e
    finally:
        conn.close()
```
- iOS端：Core Data用`NSBatchInsertRequest`/`NSBatchUpdateRequest`，FMDB封装事务逻辑，避免主线程批量写导致UI卡顿。

### 2. 内存缓存+延迟写入（非关键数据）
对“实时性要求低、高频更新”的状态（如连击数、当前精力），先缓存再批量同步：
- Python端：用`dict`缓存`user_state`表数据，间隔5分钟/累计3次修改后写入数据库；
- iOS端：用`NSCache`/全局单例缓存状态数据，后台队列（GCD）定期同步到Core Data，避免每次记录行为都写库。

### 3. 索引优化（加速高频查询）
针对计分系统的核心查询场景（按时间筛选、按等级统计）添加索引：
```sql
-- 行为记录按时间范围查询（如“今日/本周记录”）
CREATE INDEX idx_behavior_ts ON core_behavior(start_ts);
-- 按等级筛选（如统计S/A级行为总时长）
CREATE INDEX idx_behavior_level ON core_behavior(level);
```
⚠️ 注意：索引仅针对高频查询字段，避免过度索引（会增加写操作开销）。

## 四、数据体积与可靠性优化（去服务器化核心）
### 1. 数据压缩与清理策略
去服务器化场景下需控制本地数据体积，避免占用过多设备空间：
| 数据类型       | 优化策略                                                                 |
|----------------|--------------------------------------------------------------------------|
| 原始行为记录   | 保留近6个月原始数据，超过则聚合为“日汇总”（仅存总积分、总时长、平均系数），删除原始记录； |
| 历史汇总数据   | 对超过1年的汇总数据，用zlib（Python）/gzip（iOS）压缩存储，需要时解压查询； |
| 无效数据       | 每周自动清理撤回记录、测试记录，执行`VACUUM`命令回收SQLite空闲空间；     |

### 2. 数据备份与防丢失
- Python端：每日自动备份SQLite数据库文件到用户指定目录（如`~/Documents/time_manage_backup/`），支持手动导出CSV；
- iOS端：
  1. 开启iCloud Drive自动备份数据库文件（配置`Ubiquity`容器）；
  2. 支持用户手动导出JSON/CSV备份（适配iOS文件共享功能）；
  3. SQLite开启WAL模式（`PRAGMA journal_mode=WAL`），减少崩溃导致的数据损坏。

### 3. 数据校验（防篡改/损坏）
每条行为记录写入时，对核心字段（等级、时长、得分）生成MD5校验码，读取时校验：
```python
# Python示例：生成校验码
import hashlib

def generate_md5(level, duration, final_score):
    str_to_check = f"{level}_{duration}_{final_score}"
    return hashlib.md5(str_to_check.encode()).hexdigest()
```

## 五、iOS移植适配优化
1. **存储线程适配**：所有数据库操作放在后台队列（GCD），避免主线程读写导致UI卡顿；
2. **Core Data优化**：
   - 关闭自动合并上下文（`automaticallyMergesChangesFromParent = NO`）；
   - 批量导入时禁用通知（`NSManagedObjectContextDidSaveNotification`）；
3. **存储空间适配**：监控iOS设备剩余空间，当<100MB时自动触发数据聚合清理，仅保留近1个月原始记录；
4. **版本迁移**：
   - Python端用SQLAlchemy管理表结构版本，新增字段时自动执行迁移脚本；
   - iOS端用Core Data的“数据模型版本”（.xcdatamodeld）+ 映射模型，实现表结构升级时的数据无损迁移。

## 六、总结优化核心清单
| 优化维度       | 关键动作                                                                 |
|----------------|--------------------------------------------------------------------------|
| 跨平台兼容     | 统一SQLite表结构，避免Python独有存储格式；                               |
| 读写性能       | 事务批量写、索引加速查、内存缓存非关键状态；                             |
| 数据体积       | 自动聚合历史数据、压缩归档、定期清理；                                   |
| 可靠性         | WAL模式、MD5校验、iCloud/本地备份；                                      |
| iOS适配        | 后台线程读写、Core Data批量操作、存储空间监控；                           |

该优化方案既满足Python阶段快速验证功能的需求，又为后续iOS移植降低了存储层的适配成本，同时保证去服务器化场景下的本地存储效率和数据安全。